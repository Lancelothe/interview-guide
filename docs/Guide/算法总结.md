## 排序算法（sort）

![](https://image-hosting-lan.oss-cn-beijing.aliyuncs.com/sort-algorithm.png)

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
- **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
- **内排序**：所有排序操作都在内存中完成；
- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
- **时间复杂度：** 一个算法执行所耗费的时间。
- **空间复杂度**：运行完一个程序所需内存的大小

[秒懂排序算法](https://mp.weixin.qq.com/s/t0dsJeN397wO41pwBWPeTg)

[这或许是东半球讲十大排序算法最好的一篇文章 \- 掘金](https://juejin.im/post/5cff49e75188257a6b40de80#heading-4)





## 递归算法（recursion）



## 贪心算法（greed）

是指在每个阶段做选择的时候都做出当前阶段（或状态）最好的选择，并且**期望**这样做到的结果是全局最优解（但未必是全局最优解）

贪心算法其实是动态规划的一种,由于它的「贪心」，只着眼于当前阶段的最优解，所以每个子问题**只会被计算一次**，如果由此能得出全局最优解，相对于动态规划要对每个子问题求全局最优解，它的时间复杂度无疑是会下降一个量级的。



## 动态规划（dynamic programming，简称 dp）

经典题型： 最短路径问题

以下是我综合了动态规划的特点给出的动态规划的定义： 动态规划是一种**多阶段决策**最优解模型，一般用来求最值问题，多数情况下它可以采用**自下而上**的递推方式来得出每个子问题的最优解（即最优子结构），进而自然而然地得出依赖子问题的原问题的最优解。

划重点：

1. **多阶段决策**，意味着问题可以分解成子问题，子子问题，。。。，也就是说问题可以拆分成多个子问题进行求解
2. **最优子结构**，在自下而上的递推过程中，我们求得的每个子问题一定是**全局最优解**，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。
3. **自下而上**，怎样才能自下而上的求出每个子问题的最优解呢，可以肯定子问题之间是有一定联系的，即迭代递推公式，也叫「状态转移方程」，要定义好这个状态转移方程， 我们就需要定义好每个子问题的状态（DP 状态），那为啥要自下而上地求解呢，因为如果采用像递归这样自顶向下的求解方式，子问题之间可能存在大量的重叠，大量地重叠子问题意味着大量地重复计算，这样时间复杂度很可能呈指数级上升（在下文中我们会看到多个这样重复的计算导致的指数级的时间复杂度），所以自下而上的求解方式可以消除重叠子问题。

最关键的解题思路：

- 定义子问题dp状态

- 状态转移方程

求解动态规划基本思路如下（解题四步曲）

1. 判断是否可用递归来解，可以的话进入步骤 2
2. 分析在递归的过程中是否存在大量的重复子问题
3. 采用备忘录(记忆)的方式来存子问题的解以避免大量的重复计算（**剪枝**）
4. 改用自底向上的方式来递推，即动态规划

[一文学会动态规划解题技巧](https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21#wechat_redirect)

[labuladong的算法小抄 \- labuladong的算法小抄](https://labuladong.gitbook.io/algo/)

[清华学霸总结的动态规划4步曲，仅这篇动归够了](https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650127602&idx=2&sn=1b5d441ccaa1c7c907c4e5ce77404bab&chksm=f36ba1d3c41c28c569da06ab47f5bf0dffe05b51d4ed6e58eccd1bf1b5d800c9b6c0e2187cad&scene=0&xtrack=1#rd)



## 字符串

### 区分子串和子序列

- 子串

串中任意个连续的字符组成的子序列称为该串的子串

对于一个字符串变量，例如"adereegfbw",它的子串就是像"ader"这样可以从中找到的连续的字符串。字符串"adereegfbw"本身也属于它本身最长的子串。

ab的子串：a、b、ab和一个空子串共4个即（2+1+1）个，abc的子串：a、 b、 c、 ab、 bc 、abc和一个空子串 共（3+2+1+1）个，

所以若字符串的长度为n,则子串的个数就是[n*(n+1)/2]+1个，"software"中非空子串的个数就是8+7+....+1=36个。

- 子序列

子数列，又称子序列，在数学中，某个序列的子序列是从最初序列通过

去除某些元素但不破坏余下元素的相对位置（在前或在后）而形成的新序列。

“AC”是“ABCDEFG”的子序列，而不是子串。

> 如字符串： `"pwwkew"` ，
>
> 子串是pww, wwk等很多个子串 是连在一起的
>
> 子序列是 pwk, pke等很多个子序列 ，但是子序列中的字符在字符串中不一定是连在一起的。





